// HASSL grammar: aliases, sync, and rules (conditions/actions).
// Keyword-safe transformer rule names: or_, and_, not_

start: stmt*

stmt: alias
    | sync
    | rule

alias: "alias" CNAME "=" entity

// sync synctype [entity_list] as name { invert: entity_list }?
sync: "sync" synctype "[" entity_list "]" "as" CNAME syncopts?

// Explicit terminals for synctype to ensure a stable token is produced
ONOFF: "onoff"
DIMMER: "dimmer"
ATTRIBUTE: "attribute"
SHARED: "shared"
ALL: "all"
synctype: ONOFF | DIMMER | ATTRIBUTE | SHARED | ALL

syncopts: "{" ("invert" ":" entity_list) "}"

// ---- Rules ----
rule: "rule" CNAME ":" if_clause+

if_clause: "if" "(" condition ")" "then" actions

// ---- Conditions ----
?condition: expr qualifier?

qualifier: "not_by" ( "this" | "any_hassl" | "rule" "(" CNAME ")" )

?expr: expr "||" andexpr   -> or_
     | andexpr
?andexpr: andexpr "&&" term -> and_
        | term
?term: "!" term             -> not_
    | "(" expr ")"
    | comparison

comparison: operand OP operand
          | operand                -> bare_operand

OP: "==" | "!=" | "<" | ">" | "<=" | ">="

operand: entity | CNAME | STATE | NUMBER | STRING

STATE: "on" | "off"
NUMBER: INT | SIGNED_NUMBER

// ---- Actions ----
actions: action (";" action)*

action: assign
      | attr_assign
      | waitact
      | rulectrl
      | tagact

assign: CNAME "=" STATE ("for" dur)?

// Unambiguous attribute assignment: N>=2 segments for entity, then an attribute name
attr_assign: CNAME "." CNAME ("." CNAME)* "." CNAME "=" NUMBER

waitact: "wait" "(" condition "for" dur ")" action

rulectrl: ("disable" | "enable") "rule" CNAME "for" dur

tagact: "tag" CNAME "=" (STRING | CNAME | NUMBER)

// Duration: integer + unit
dur: INT UNIT
UNIT: "ms" | "s" | "m" | "h" | "d"

// ---- Atoms ----
entity_list: entity ("," entity)*

entity: CNAME ("." CNAME)+

// ---- Lexer ----
COMMENT: /#[^
]*/
%ignore COMMENT
%import common.CNAME
%import common.WS
%import common.ESCAPED_STRING -> STRING
%import common.INT
%import common.SIGNED_NUMBER
%ignore WS
